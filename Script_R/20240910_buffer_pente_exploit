### Chargement des library
library(readxl)
library(happign)
library(tmap)
library(sf)
library(dplyr)  
tmap_mode("view")
library(terra)
library(raster)



### Fonction ----
# Fonction pour créer et visualiser des buffers autour des routes avec tmap
create_and_visualize_buffers <- function(shape_route_path) {
  
  # Lire le shapefile des routes
  shape_routes <- st_read(shape_route_path)
  
  # Vérifier si les géométries sont valides, sinon les corriger
  shape_routes <- st_make_valid(shape_routes)
  
  # Créer des buffers à différentes distances
  buffer_20m <- st_buffer(shape_routes, dist = 20)
  buffer_50m <- st_buffer(shape_routes, dist = 50)
  buffer_100m <- st_buffer(shape_routes, dist = 100)
  
  # Sauvegarder les buffers dans des fichiers shapefile (avec écrasement)
  st_write(buffer_20m, "buffer_20m.shp", append = FALSE)
  st_write(buffer_50m, "buffer_50m.shp", append = FALSE)
  st_write(buffer_100m, "buffer_100m.shp", append = FALSE)
  
  # Afficher un message de confirmation
  message("Les buffers ont été enregistrés sous les fichiers buffer_30m.shp, buffer_50m.shp, et buffer_100m.shp.")
  
  # Visualiser les buffers et les routes avec tmap, avec opacité contrôlée
  tmap_mode("view")  # Mode "view" pour une carte interactive
  
  tm_shape(buffer_100m) + 
    tm_polygons(col = "blue", border.col = "blue") +  # Buffer 100m
    tm_shape(buffer_50m) + 
    tm_polygons(col = "green", border.col = "green") +  # Buffer 50m
    tm_shape(buffer_20m) + 
    tm_polygons(col = "red", border.col = "red") +  # Buffer 30m
    tm_shape(shape_routes) + 
    tm_lines(col = "black", lwd = 3) +  # Routes
    tm_shape(Saxel_parca_pci) +
    tm_borders(col = "gray", lwd = 3) +
    tm_layout(title = "Buffers d'exploitation autour des routes")
}

### Script ----
## Importation des données cadastrales de la zone d'étude ----
# Créer un vecteur de nombres de 300 à 400
nombres <- 1500:1600

# Convertir les nombres en chaînes de caractères avec formatage à 4 chiffres
vecteur_chaine <- sprintf("%04d", nombres)

# Interroger une parcelle spécifique
Saxel_parca_pci <- get_apicarto_cadastre(
  x = "74261",               # Code INSEE en tant que chaîne
  type = "parcelle",         # Type de données : parcelle
  section = "0A",            # Section (vérifie si "OA" est correct pour cette commune)
  numero = vecteur_chaine,   # Numéros de parcelle (en boucle si nécessaire)
  source = "PCI",            # Source des données
)

# Visualiser les résultats
qtm(Saxel_parca_pci)
Saxel_parca_pci_2154 <- st_transform(Saxel_parca_pci,
                                      2154)
st_write(Saxel_parca_pci_2154,
         "testRprojet.gpkg",
         layer = "Saxel_parca_pci_2154",
         append = TRUE)

st_layers("Saxel_parca_pci_2154")



## Exemple d'utilisation de la fonction buffer ----

# Spécifie le chemin du fichier des routes et les distances de buffer
shape_route_path <- "C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Couche_desserte.gpkg"

# Appel de la fonction pour créer les buffers
buffers <- create_and_visualize_buffers(shape_route_path)

# Vérifier le contenu des buffers
print(buffers)


### Ajout des pentes ----
# Set working directory
setwd("C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Projet-R/Résultats")

## Enregistrement du parcellaire en format .gpkg
gpkg_path <- "C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Projet-R/Script_R/MNT_pente/projet5.gpkg"
st_write(Saxel_parca_pci,
         gpkg_path,
         layer = "zone_parca",
         append = TRUE
)

## Importation du MNT de la zone d'étude

layers <- get_layers_metadata("wms-r", "altimetrie" )
mnt_layer_name <- "ELEVATION.ELEVATIONGRIDCOVERAGE"

mnt <- get_wms_raster(x = Saxel_parca_pci,
                      layer = mnt_layer_name, 
                      res = 10,
                      rgb = FALSE,
                      filename = "C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Projet-R/Script_R/MNT_pente/mnt.tif",  # automatiser le chemin d'accès
                      overwrite = TRUE
)
# essayer d'ajouter le mnt au gpkg ainsi qu'un buffer de 100m autour de la parcelle

tm_shape(mnt)+
  tm_raster()+
  tm_shape(Saxel_parca_pci)+
  tm_borders("black", lwd = 2)

# Calcul de la pente ----

pente <- terrain(mnt,
                 v = "slope",
                 unit = "degrees",
                 filename = "C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Projet-R/Script_R/MNT_pente/pente.tif",
                 overwrite = TRUE
)

classes <- c(0, 5, 15, 30, 45, 60, 90)
classes_pente <- classify(pente, classes)
plot(classes_pente)

tm_shape(pente)+
  tm_raster()+
  tm_shape(Saxel_parca_pci)+
  tm_borders("black", lwd = 2)

### Calcul de l'exploitabilité ----


# Créer un raster pour la distance
distance_raster <- rast(ext(pente), res = res(pente))
crs(distance_raster) <- crs(pente)  # Assurer que les CRS sont identiques

# Créer un raster de distance à partir des buffers
for (buffer in buffers) {
  buffer_raster <- rasterize(as(buffer, "Spatial"), distance_raster, fun = "min", background = NA)
  distance_raster <- min(distance_raster, buffer_raster, na.rm = TRUE)
}

# Reclassifier le raster de distance
distance_reclass <- classify(distance_raster, rcl = matrix(c(
  0, 50, 1,  # Distance <= 50m devient 1 (très facile)
  50, 100, 2, # Distance entre 50m et 100m devient 2 (moyenne)
  100, Inf, 3 # Distance > 100m devient 3 (difficile)
), ncol = 3, byrow = TRUE))

# Reclassifier le raster de pente
pente_reclass <- classify(pente_raster, rcl = matrix(c(
  0, 30, 1,  # Pente <= 30% devient 1 (exploitable)
  30, Inf, 2  # Pente > 30% devient 2 (non exploitable)
), ncol = 3, byrow = TRUE))

# Créer un raster final pour l'exploitabilité
exploitability_raster <- overlay(pente_reclass, distance_reclass, fun = function(p, d) {
  if (p == 1 && d == 1) return(1)  # Très facile
  if (p == 1 && d == 2) return(2)  # Moyenne
  return(3)  # Difficile
})

# Convertir le raster final en polygones
exploitability_polygons <- as.polygons(exploitability_raster, values = TRUE, drop = TRUE)

# Sauvegarder les polygones en shapefiles
st_write(as_sf(exploitability_polygons), file.path(output_directory, "exploitability_map.shp"), append = FALSE)

# Retourner le résultat pour vérification
return(exploitability_polygons)


  
# Exemple d'utilisation de la fonction
# Spécifie les chemins des fichiers nécessaires
shape_route_path <- "C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Couche_desserte.gpkg"
mnt_path <- "C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Projet-R/Script_R/MNT_pente/mnt.tif"
distances <- c(20, 50, 100)
output_slope_path <- "C:/Users/louis/OneDrive/Documents/AgroParistech/3AA/Cours R/Projet_exploit/Projet-R/Script_R/MNT_pente/pente_exploit.tif"

# Appel de la fonction pour créer et visualiser la carte d'exploitabilité
create_exploitability_map(shape_route_path, mnt_path, distances, output_slope_path)
