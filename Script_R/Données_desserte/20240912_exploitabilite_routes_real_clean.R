# Introduction ----
# Auteur : Killian
# Date : 12 septembre 2024
# Contact : killian.baue@agroparistech.fr
#
# Ce script R est utilise pour traiter et analyser les donnees geographiques
# en relation avec les routes et chemins forestiers dans une commune donnee.
# Les principales etapes incluent le chargement des donnees cadastrales, 
# la verification de l'exploitabilite des pistes, la creation de cartes 
# et la sauvegarde des resultats dans un fichier GeoPackage. 
# Le script est concu pour etre utilise avec un code INSEE specifique pour
# extraire et traiter les donnees correspondantes.

# Chargement des librairies ----

library(happign)
library(tmap)
library(sf)
library(dplyr)
library(terra)
tmap_mode("view")

# Fonction de chargement des donnees cadastrales ----
# Cette fonction charge les donnees cadastrales pour une commune donnee, 
# les transforme en Lambert 93 et retourne les donnees projetees.

charger.cadastre <- function(code_insee) {
  donnees <- get_apicarto_cadastre(
    x = code_insee,               
    type = "parcelle",         
    source = "pci",            
    progress = TRUE            
  )
  st_transform(donnees, crs = 2154)  # Re-projection en Lambert 93
}

# Fonction de chargement des routes ----
# Cette fonction charge les donnees de troncons de routes pour une zone bufferisee.
# Elle utilise les donnees WFS pour obtenir les troncons de route dans la zone specifiee
# et les projette en Lambert 93.

charger.routes <- function(zone_buffer) {
  routes <- get_wfs(zone_buffer, 
                    "BDTOPO_V3:troncon_de_route",
                    spatial_filter = "intersects")
  st_transform(routes, crs = 2154)  # Re-projection en Lambert 93
}

# Fonction de verification de l'exploitabilite des chemins ----
# Cette fonction verifie l'exploitabilite des pistes skidders en fonction de leur 
# connexion directe ou indirecte aux routes accessibles aux grumiers.
# Elle retourne les pistes exploitables, les pistes non exploitables et les places de depot.
verifier.exploitabilite <- function(pistes_skidders, routes_grumiers, routes_sentiers) {
  # Creation d'un buffer de 5 m autour des routes accessibles aux grumiers
  buffer_grumier <- st_buffer(routes_grumiers, dist = 5)
  
  # Verification de la connexion directe entre les pistes skidders et le buffer des routes grumiers
  connexions_directes <- st_intersects(pistes_skidders, buffer_grumier, sparse = FALSE)
  pistes_connectees <- rowSums(connexions_directes) > 0
  pistes_directes <- pistes_skidders[pistes_connectees, ]
  pistes_indirectes <- pistes_skidders[!pistes_connectees, ]
  
  # Initialisation de la liste des pistes exploitables avec celles directement connectees
  pistes_exploitables <- pistes_directes
  
  # Expansion des pistes exploitables par ajout des pistes indirectement connectees
  repeat {
    buffer_exploitables <- st_buffer(pistes_exploitables, dist = 5)
    connexions_indirectes <- st_intersects(pistes_indirectes, buffer_exploitables, sparse = FALSE)
    nouvelles_pistes <- rowSums(connexions_indirectes) > 0
    nouvelles_exploitables <- pistes_indirectes[nouvelles_pistes, ]
    
    # Si aucune nouvelle piste n'est connectee, arreter la boucle
    if (nrow(nouvelles_exploitables) == 0) break
    
    # Ajouter les nouvelles pistes exploitables a la liste existante
    pistes_exploitables <- rbind(pistes_exploitables, nouvelles_exploitables)
    pistes_indirectes <- pistes_indirectes[!nouvelles_pistes, ]
  }
  
  # Identifier les pistes non exploitables
  pistes_non_exploitables <- pistes_indirectes
  
  # Identifier les intersections entre les pistes exploitables et les routes grumiers
  intersections <- st_intersection(pistes_exploitables, routes_grumiers)
  places_depot <- st_collection_extract(intersections, type = "POINT")
  
  # Retourner les resultats sous forme de liste
  list(pistes_exploitables = pistes_exploitables, 
       pistes_non_exploitables = pistes_non_exploitables, 
       places_depot = places_depot)
}

# Fonction pour creer la carte ----
# Cette fonction cree une carte a partir des couches fournies et retourne l'objet carte.
creer.carte <- function(cadastre, routes_grumiers, pistes_exploitables, pistes_non_exploitables, routes_sentiers, places_depot) {
  tm_shape(cadastre) +
    tm_borders(col = "black", lwd = 1) +
    tm_shape(routes_grumiers) + 
    tm_lines(col = "blue", lwd = 1.5, title.col = "Routes Grumiers") +
    tm_shape(pistes_exploitables) + 
    tm_lines(col = "green", lwd = 1, title.col = "Pistes Exploitables") +
    tm_shape(pistes_non_exploitables) + 
    tm_lines(col = "red", lwd = 1, title.col = "Routes Non Exploitables") +
    tm_shape(routes_sentiers) + 
    tm_lines(col = "#808080", lwd = 1, title.col = "Sentiers") +
    tm_shape(places_depot) + 
    tm_dots(col = "yellow", size = 0.1, title = "Places de Depot") +
    tm_layout(legend.outside = TRUE, legend.position = c("left", "bottom"), 
              legend.title.size = 1, legend.text.size = 0.8)
}

# Fonction pour sauvegarder les couches dans un GeoPackage ----
# Cette fonction sauvegarde une couche dans un fichier GeoPackage a l'emplacement specifie.
sauvegarder.couche <- function(donnees_couche, chemin_gpkg, nom_couche) {
  st_write(donnees_couche, chemin_gpkg, layer = nom_couche, delete_layer = TRUE)
}

# Fonction principale ----
# Cette fonction genere un GeoPackage pour une commune donnee a partir du code INSEE. 
# Elle appelle les fonctions de chargement des donnees, de verification de l'exploitabilite, 
# de creation de la carte et de sauvegarde des couches dans un GeoPackage.
obtention.desserte <- function(code_insee) {
  # Chargement des donnees cadastrales
  cadastre <- charger.cadastre(code_insee)
  
  # Creation du buffer de 1 km autour des parcelles cadastrales
  zone_buffer <- st_buffer(cadastre, dist = 1000)
  
  # Chargement des routes dans la zone de buffer
  routes <- charger.routes(zone_buffer)
  
  # Selection des types de routes
  routes_grumiers <- routes %>% filter(nature %in% c("Route a 1 chauss√©e", "Route empierre"))
  pistes_skidders <- routes %>% filter(nature == "Chemin")
  routes_sentiers <- routes %>% filter(nature == "Sentier")
  
  # Verification de l'exploitabilite
  resultats_exploitabilite <- verifier.exploitabilite(pistes_skidders, routes_grumiers, routes_sentiers)
  
  # Creation de la carte
  carte <- creer.carte(cadastre, routes_grumiers, 
                       resultats_exploitabilite$pistes_exploitables, 
                       resultats_exploitabilite$pistes_non_exploitables, 
                       routes_sentiers, 
                       resultats_exploitabilite$places_depot)
  
  # Affichage de la carte
  print(carte)
  
  # Sauvegarde des resultats dans un GeoPackage
  chemin_gpkg <- paste0("exploitabilite_desserte_", code_insee, ".gpkg")
  couches_a_sauvegarder <- list(
    "cadastre" = cadastre,
    "troncons_routes" = routes,
    "sentiers" = routes_sentiers,
    "routes_grumiers" = routes_grumiers,
    "pistes_exploitables" = resultats_exploitabilite$pistes_exploitables,
    "pistes_non_exploitables" = resultats_exploitabilite$pistes_non_exploitables,
    "places_depot" = resultats_exploitabilite$places_depot
  )
  
  # Sauvegarder chaque couche dans le GeoPackage
  for (nom_couche in names(couches_a_sauvegarder)) {
    sauvegarder.couche(couches_a_sauvegarder[[nom_couche]], chemin_gpkg, nom_couche)
  }
  
  print(paste("GeoPackage genere avec succes :", chemin_gpkg))
}

# Appel de la fonction principale avec un code INSEE
obtention.desserte("74261")
