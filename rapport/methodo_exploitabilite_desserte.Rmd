---
title: "Discrimination des surfaces par distance de débardage et par analyse de pentes"
author: "Killian BAUE, Agnès DAVIERE, Louise DUBOST, Elda PERONNET"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true 
    toc_depth: 3
  html_document:
    toc: true 
    toc_depth: 3
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=FALSE, fig.align='center', out.width='100%'}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
knitr::include_graphics("images/APT_Logo_RVB_Positif.png")
```

# Presentation du projet

Identifier les zones les plus accessibles et les plus adaptées aux 
opérations de débardage est essentiel pour les gestionnaires forestiers.
Ce projet a pour objectif d’automatiser la détermination de catégorie de 
surface selon la distance de débardage et la pente sur une zone connue. La 
distance de débardage par rapport à la desserte est classée selon 3 
catégories : 20 – 50 – 100m [@IGN]. La couche de desserte et le
MNT sont récupérés à partir du package `happign` [@happign] de R. Le 
traitement a ensuite été réalisé en parallèle avec Rstudio et QGis afin de 
mener une étude comparative. 

Petite phrase pour dire si oui ou non on y est parvenu ( :

# Méthode
## Choix de la zone d'étude 

LLa zone d'étude a été choisie de manière à respecter plusieurs critères : 

- Elle doit tout d'abord comporter des zones forestières ; 

- Elle doit idéalement présenter une topographie permettant d'avoir différentes valeurs de pentes afin d'avoir des niveaux d'exploitabilité divergeant selon ce facteur ;

- La zone d'étude doit également posséder un réseau de desserte d'une taille suffisante et divers (en nature de routes) afin de permettre une analyse pertinente ; 

- Les données (différentes sources de MNT, dessertes,etc.) relatives à la zone d'étude doivent être importables. La majorité du type de données mobilisées au cours de ce projet couvre l'ensemble du territoire national, à l'exception des données Lidar. Un axe d'étude étant la comparaison de différentes sources de MNT, il serait plus judicieux de choisir une zone d'étude ayant déjà fait l'objet d'une campagne Lidar et dont les données retraitées sont disponibles ; 

- Enfin, afin de faciliter l'import des données IGN, elle ne doit pas s'étendre sur une trop grande surface.

La commune d'étude à été choisie suite à des vérifications succinctes des critères précédents sur géoportail. La commune de Saxel, en Haute-Savoie a ainsi été retenue.

Saxel est une commune de 500 habitants recouverte à plus de 60 % par des zones forestières.

lien wikipedia : https://fr.wikipedia.org/wiki/Saxel


L'obtention du cadastre de la commune se fait via la fonction `get_apicarto_cadastre()` du package `happign`.

Ci-dessous, la fonction permettant l'import des données cadastrales : 

```{r}

importer.cadastre <- function(insee_code) {
  # importation des parcelles cadastrales avec le code insee
  get_apicarto_cadastre(
    x = insee_code,                # code insee de la commune
    type = "parcelle",             # type de donnees, ici 'parcelle'
    source = "pci",                # source des donnees 'pci'
    progress = TRUE                # affichage de la progression
  )
}

```

Les données cadastrales sont re-projetées en système de coordonnées Lambert 93 (EPSG:2154). Cette re-projection permets que toutes les données géographiques soient alignées dans le même système de référence.


## Recherche et caractérisation de la desserte

L'objectif est d'importer la desserte routière de la zone d'étude.

Pour cela, nous utilisons la fonction `importer.routes()` permettant de récupérer les tronçons de route dans une zone tampon spécifié en utilisant une requête WFS (Web Feature Service). La zone tampon est définie par l'utilisateur, et seuls les tronçons de route interceptant cette zone sont importés, en se basant sur la couche de données "BDTOPO_V3
". Pour s'assurer que toutes les routes, y compris les pistes, de la zone d'étude sont connectées aux routes accessibles aux grumiers, un buffer de 1 km est créé autour des routes importée.

```{r}


## Fonction pour importer les routes ----
importer.routes <- function(zone_tampon) {
  # importation des troncons de route dans une zone tampon
  get_wfs(zone_tampon,                        # zone tampon pour la requete WFS
          "BDTOPO_V3:troncon_de_route",       
          spatial_filter = "intersects"       
  )  
}

```


La fonction `reprojeter.donnees()` est utilisée pour re-projeter des données spatiales dans un système de coordonnées spécifique, ici le système Lambert 93. En prenant en entrée les données spatiales et le code du système de coordonnées (CRS), cette fonction applique la transformation nécessaire via la fonction `st_transform()`, garantissant ainsi que les données sont alignées avec le système de coordonnées Lambert 93 utilisé pour l'analyse.

```{r}

## Fonction pour re-projeter les donnees spatiales ----
reprojeter.donnees <- function(donnees,
                               code_crs) {
  # Reprojection des donnees spatiales dans le systeme de coordonnees specifie
  st_transform(donnees, crs = code_crs)
}

```


Une fois les données routières importées, il est nécessaire de vérifier la nature des routes (chemin, sentier, etc.) en consultant la table attributaire du vecteur. La colonne nature dans la table attributaire contient des informations sur le type de chaque tronçon de route, cette analyse permet d'obtenir un aperçu de la répartition des types de routes dans la zone d'étude.


Par la suite, nous définissons que :

- Les routes à une chaussée ainsi que les routes empierrées sont accessibles aux grumiers ;

- Les chemins sont accessibles au skidder / tracteurs forestiers ;

- Les sentiers ne sont pas comptabilisés dans l'analyse bien que ces derniers peuvent être empruntés par les bûcherons en cas d'abatage manuel (ce qui très probablement le cas dans un contexte alpin). 


```{r}
## Fonction pour filtrer les routes par type ----
filtrer.routes <- function(routes) {
  # Creation des sous-ensembles de routes selon leur nature
  routes_grumiers <- routes %>%
    filter(nature %in% c("Route à 1 chaussée", "Route empierrée"))
  
  routes_skidders <- routes %>%
    filter(nature == "Chemin")
  
  routes_sentiers <- routes %>%
    filter(nature == "Sentier")
  
  list(
    routes_grumiers = routes_grumiers,
    routes_skidders = routes_skidders,
    routes_sentiers = routes_sentiers
  )
}


```


Cette classification permet de catégoriser les différents types de routes et chemins, facilitant ainsi l'analyse de leur exploitabilité.


L'étape suivante est de pouvoir classifier les différentes routes comme étant exploitables ou non. Dans cet objectif, la fonction `verifier.exploitabilite()` a pour objectif d’évaluer l'exploitabilité des pistes en vérifiant leur connexion directe ou indirecte avec les routes accessibles aux grumiers. La fonction procède selon les étapes suivantes :



- Création d’un buffer autour des routes grumiers : Un buffer de 5 mètres est généré autour des routes accessibles aux grumiers. Ce buffer permet de définir une zone d’influence autour de ces routes ; 

- Vérification de la connexion directe : La fonction utilise `st_intersects()` pour déterminer si les pistes (routes skidders) se trouvent dans cette zone tampon. Les pistes connectées directement aux routes grumiers sont identifiées, tandis que celles qui ne le sont pas restent dans une liste distincte ; 

- Identification des connexions indirectes : pour les pistes non connectées directement, un processus itératif est utilisé pour vérifier si elles peuvent être connectées indirectement. Un nouveau buffer de 5 mètres est créé autour des pistes déjà identifiées comme exploitables, et les pistes non connectées sont testées à nouveau pour voir si elles se trouvent dans ce buffer. Ce processus se répète jusqu'à ce qu'aucune nouvelle piste exploitée ne soit trouvée ;

- Intersection et extraction des points : une fois toutes les pistes exploitables identifiées, la fonction calcule l'intersection entre ces pistes et les routes accessibles aux grumiers pour déterminer les points de connexion. Si ces intersections ne sont pas des points individuels, elles sont extraites comme tels à l’aide de `st_collection_extract()`.

```{r}
## Fonction pour verification de l'exploitabilite des pistes ----
verifier.exploitabilite <- function(routes_skidders,
                                    routes_grumiers,
                                    routes_sentiers,
                                    cadastre_2154) {
  # Creation d'un buffer de 5 m autour des routes grumiers
  buffer_grumiers <- st_buffer(routes_grumiers, dist = 5)
  
  # Verification de la connexion directe entre skidders et grumiers
  connexion_directe <- st_intersects(routes_skidders, buffer_grumiers, sparse = FALSE)
  skidders_connectes <- routes_skidders[rowSums(connexion_directe) > 0, ]
  
  skidders_non_connectes <- routes_skidders[rowSums(connexion_directe) == 0, ]
  
  tous_skidders_exploitables <- skidders_connectes
  
  # Boucle pour trouver les connexions indirectes
  repeat {
    buffer_exploitables <- st_buffer(tous_skidders_exploitables, dist = 5)
    connexion_indirecte <- st_intersects(skidders_non_connectes, buffer_exploitables, sparse = FALSE)
    
    nouveaux_exploitables <- skidders_non_connectes[rowSums(connexion_indirecte) > 0, ]
    
    if (nrow(nouveaux_exploitables) == 0) break
    
    tous_skidders_exploitables <- rbind(tous_skidders_exploitables, nouveaux_exploitables)
    skidders_non_connectes <- skidders_non_connectes[rowSums(connexion_indirecte) == 0, ]
  }
  
  # Intersection entre chemins exploitables et routes grumiers
  intersections <- st_intersection(tous_skidders_exploitables, routes_grumiers)
  if (!inherits(intersections, "POINT")) {
    place_de_depot <- st_collection_extract(intersections, type = "POINT")
  } else {
    place_de_depot <- intersections
  }

```



Les résultats obtenus sont sauvegardés dans un fichier GeoPackage. Une fonction dédiée `save_layer()` est utilisée pour enregistrer chaque couche de données dans le fichier. Les couches incluses sont :

- Les données cadastrales de la zone d'étude (i.e la commune de Saxel) ; 

- Les tronçons de route (desserte globale) ; 

- Les sentiers (à titre informatif) ; 

- Les pistes exploitables (réutilisée dans la suite du projet) ;

- Les pistes non-exploitables ;

- Les places de dépôt.

```{r}

## Fonction pour sauvegarder une couche dans un fichier geopackage ----
sauvegarder.couche <- function(donnees, chemin_fichier, nom_couche) {
  # Ecriture de la couche dans un geopackage
  st_write(donnees, chemin_fichier, layer = nom_couche, delete_layer = TRUE)
}

```